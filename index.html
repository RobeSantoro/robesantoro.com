<!DOCTYPE html>
<html lang="en">

    <head>
        <title>robesantoro.com</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        
        <style>
            * {
                margin: 0;
                padding: 0;
            }
        </style>
        <!-- <link type="text/css" rel="stylesheet" href="main.css"> -->
    </head>

    <body>
        <script type="module">

            import * as THREE from './build/three.module.js';

            import { OrbitControls } from "./js/OrbitControls.js";

            import Stats from './libs/stats.module.js';
            import { GUI } from './libs/dat.gui.module.js';

            import { EffectComposer } from './postprocessing/EffectComposer.js';
            import { SSAOPass } from './postprocessing/SSAOPass.js';

            let container, stats;
            let camera, controls, scene, renderer;
            let composer;
            let mesh;

            let INTERSECTED;

            /// RAYCASTER \\\

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2(1, 1);

            const width = window.innerWidth;
            const height = window.innerHeight;

            const color = new THREE.Color();


            init();
            animate();

            function init() {

                container = document.createElement('div');
                document.body.appendChild(container);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                /// SCENE \\\
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x333333);

                scene.add(new THREE.DirectionalLight());
                scene.add(new THREE.HemisphereLight());

                /// CAMERA \\\
                camera = new THREE.PerspectiveCamera(15, window.innerWidth / window.innerHeight, 0.1, 600);
                camera.position.set(-40, 40, 40);
                camera.lookAt(0, 0, 0);

				controls = new OrbitControls( camera, renderer.domElement );
				controls.listenToKeyEvents( window ); // optional

				//controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

				controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.05;

				controls.screenSpacePanning = false;

				controls.minDistance = 10;                
				controls.maxDistance = 500;


                /// INSTANCES \\\

                let i = 0;

                const x_repeat = 15;
                const y_repeat = 40;
                const count = x_repeat * y_repeat;

                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshPhongMaterial({ color: 0x333333 });

                mesh = new THREE.InstancedMesh(geometry, material, count);

                const matrix = new THREE.Matrix4();

                for (let y = -10; y < y_repeat; y++) {                    
                    
                    for (let x = -16; x < x_repeat; x++) {
                        
                        matrix.setPosition(x, y, x+-y);
                        
                        mesh.setMatrixAt(i, matrix);
                        mesh.setColorAt(i, color);
                        
                        i++;
                    }
                }

                scene.add(mesh);



                /// STATS \\\
                stats = new Stats();
                container.appendChild(stats.dom);

                const width = window.innerWidth;
                const height = window.innerHeight;

                /// SSAO \\\
                composer = new EffectComposer(renderer);

                const ssaoPass = new SSAOPass(scene, camera, width, height);
                ssaoPass.kernelRadius = 32;
                ssaoPass.minDistance = 0.001;
                ssaoPass.maxDistance = 0.3;

                composer.addPass(ssaoPass);

                // GUI \\\
                const gui = new GUI();

                gui.add(ssaoPass, 'output', {
                    'Default': SSAOPass.OUTPUT.Default,
                    'SSAO Only': SSAOPass.OUTPUT.SSAO,
                    'SSAO Only + Blur': SSAOPass.OUTPUT.Blur,
                    'Beauty': SSAOPass.OUTPUT.Beauty,
                    'Depth': SSAOPass.OUTPUT.Depth,
                    'Normal': SSAOPass.OUTPUT.Normal
                }).onChange(function (value) {
                    ssaoPass.output = parseInt(value);
                });

                gui.add(ssaoPass, 'kernelRadius').min(0).max(32);
                gui.add(ssaoPass, 'minDistance').min(0.001).max(0.02);
                gui.add(ssaoPass, 'maxDistance').min(0.01).max(0.3);

                /// GRID \\\
/*              const size = 20;
                const divisions = 20;

                const gridHelper = new THREE.GridHelper(size, divisions);
                scene.add(gridHelper);

                const axesHelper = new THREE.AxesHelper(5);
                scene.add(axesHelper); */

                /// EVENT LISTENER \\\
                window.addEventListener('resize', onWindowResize);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener( 'click', onClick);
                //document.addEventListener( 'mousedown', onMouseDown);



            }

            function onWindowResize() {

                const width = window.innerWidth;
                const height = window.innerHeight;

                camera.aspect = width / height;
                camera.updateProjectionMatrix();

                renderer.setSize(width, height);
                composer.setSize(width, height);

            }

            function onMouseMove( event ) {
                event.preventDefault();
                //controls.enabled = true
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            }

            function onClick( event ) {
                event.preventDefault();
                //controls.enabled = false
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
                /// RAYCASTING \\\
                raycaster.setFromCamera(mouse, camera);

                const intersection = raycaster.intersectObject(mesh);

                if (intersection.length > 0) {

                    const instanceId = intersection[0].instanceId;

                    if (INTERSECTED != intersection[0].instanceId) {
                        //console.log(instanceId);
                        let activeColor 

                        mesh.setColorAt(instanceId, color.setHex( Math.random() * 0xffffff) );
                        mesh.instanceColor.needsUpdate = true;

                        console.log(instanceId);

                    }  
                    
                } 
            }

            function animate() {

                requestAnimationFrame(animate);
                controls.update(); 


                stats.begin();
                render();
                stats.end();

            }

            function render() {

                const timer = performance.now();  
                
                composer.render();
            }

        </script>
    </body>

</html>